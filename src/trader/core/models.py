"""Core domain models for the trading platform."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any
from uuid import uuid4


class TimeFrame(str, Enum):
    """Supported timeframes for market data."""

    MINUTE_1 = "1Min"
    MINUTE_5 = "5Min"
    MINUTE_15 = "15Min"
    MINUTE_30 = "30Min"
    HOUR_1 = "1Hour"
    HOUR_4 = "4Hour"
    DAY = "1Day"
    WEEK = "1Week"


class SignalAction(str, Enum):
    """Trading signal actions."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class OrderSide(str, Enum):
    """Order side (buy or sell)."""

    BUY = "buy"
    SELL = "sell"


class OrderType(str, Enum):
    """Order types."""

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderStatus(str, Enum):
    """Order status."""

    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


@dataclass
class Bar:
    """OHLCV bar data."""

    symbol: str
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int
    timeframe: TimeFrame = TimeFrame.DAY

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "symbol": self.symbol,
            "timestamp": self.timestamp.isoformat(),
            "open": float(self.open),
            "high": float(self.high),
            "low": float(self.low),
            "close": float(self.close),
            "volume": self.volume,
            "timeframe": self.timeframe.value,
        }


@dataclass
class Signal:
    """Trading signal generated by a strategy."""

    action: SignalAction
    symbol: str
    timestamp: datetime = field(default_factory=datetime.utcnow)
    quantity: int | None = None
    confidence: float = 1.0
    reason: str = ""
    stop_loss: Decimal | None = None
    take_profit: Decimal | None = None
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate signal after initialization."""
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")


class OrderClass(str, Enum):
    """Order class for bracket orders."""

    SIMPLE = "simple"  # Single order
    BRACKET = "bracket"  # Entry + stop loss + take profit
    OCO = "oco"  # One-cancels-other (stop loss OR take profit)
    OTO = "oto"  # One-triggers-other


@dataclass
class Order:
    """Order to be submitted to a broker."""

    symbol: str
    side: OrderSide
    quantity: int
    order_type: OrderType = OrderType.MARKET
    limit_price: Decimal | None = None
    stop_price: Decimal | None = None
    status: OrderStatus = OrderStatus.PENDING
    order_id: str = field(default_factory=lambda: str(uuid4()))
    broker_order_id: str | None = None
    filled_quantity: int = 0
    filled_avg_price: Decimal | None = None
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    signal: Signal | None = None

    # Bracket order fields
    order_class: OrderClass = OrderClass.SIMPLE
    stop_loss_price: Decimal | None = None  # Stop loss trigger price
    stop_loss_limit_price: Decimal | None = None  # Optional limit for stop loss
    take_profit_price: Decimal | None = None  # Take profit limit price

    def __post_init__(self) -> None:
        """Validate order after initialization."""
        if self.quantity <= 0:
            raise ValueError("Quantity must be positive")
        if self.order_type == OrderType.LIMIT and self.limit_price is None:
            raise ValueError("Limit price required for limit orders")
        if self.order_type == OrderType.STOP and self.stop_price is None:
            raise ValueError("Stop price required for stop orders")
        if self.order_class == OrderClass.BRACKET:
            if self.stop_loss_price is None and self.take_profit_price is None:
                raise ValueError("Bracket orders require stop_loss or take_profit")


@dataclass
class Position:
    """Current position in a security."""

    symbol: str
    quantity: int
    avg_entry_price: Decimal
    current_price: Decimal | None = None
    market_value: Decimal | None = None
    unrealized_pnl: Decimal | None = None
    unrealized_pnl_pct: float | None = None
    side: OrderSide = OrderSide.BUY

    @property
    def is_long(self) -> bool:
        """Check if this is a long position."""
        return self.quantity > 0

    @property
    def is_short(self) -> bool:
        """Check if this is a short position."""
        return self.quantity < 0

    def update_price(self, price: Decimal) -> None:
        """Update current price and recalculate P&L."""
        self.current_price = price
        self.market_value = price * abs(self.quantity)

        cost_basis = self.avg_entry_price * abs(self.quantity)
        if self.is_long:
            self.unrealized_pnl = self.market_value - cost_basis
        else:
            self.unrealized_pnl = cost_basis - self.market_value

        if cost_basis > 0:
            self.unrealized_pnl_pct = float(self.unrealized_pnl / cost_basis)
